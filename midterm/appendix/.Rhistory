pred_y_corrected_bonus <- exp(pred_log_bonus) * smearing_factor_bonus
rmse_bonus <- sqrt(mean((pred_y_corrected_bonus - opa_census_2_clean$sale_price_predicted)^2, na.rm = TRUE))
rmse_bonus
rmse_norm <- rmse_bonus / mean(opa_census_2_clean$sale_price_predicted)
rmse_norm
options(scipen = 999)
plot(opa_census_2_clean$sale_price_predicted, pred_y_corrected_bonus,
xlab = "Actual Price", ylab = "Predicted Price",
main = "Predicted vs Actual Sale Price",
pch = 19, col = rgb(0.2,0.4,0.6,0.4))
abline(0,1,col="red",lwd=2)
opa_census_all_clean <- opa_census_all %>%
filter(!is.na(number_of_bathrooms))
pred_log_bonus2 <- predict(model_bonus3, newdata = opa_census_all_clean)
smearing_factor_bonus <- mean(exp(residuals(model_bonus3)))
pred_y_corrected_bonus <- exp(pred_log_bonus2) * smearing_factor_bonus
rmse_bonus <- sqrt(mean((pred_y_corrected_bonus - opa_census_all_clean$sale_price_predicted)^2, na.rm = TRUE))
rmse_bonus
rmse_norm <- rmse_bonus / mean(opa_census_all_clean$sale_price_predicted)
rmse_norm
options(scipen = 999)
plot(opa_census_all_clean$sale_price_predicted, pred_y_corrected_bonus,
xlab = "Actual Price", ylab = "Predicted Price",
main = "Predicted vs Actual Sale Price",
pch = 19, col = rgb(0.2,0.4,0.6,0.4))
abline(0,1,col="red",lwd=2)
names(opa_census_all)
vars_in_model <- c("total_livable_area", "number_of_bathrooms", "house_age",
"median_income", "ba_rate", "crime_count",
"transit_count", "nearest_hospital_m", "geographic_ward.y")
# 检查这些变量的缺失情况
colSums(is.na(opa_census_all_clean[, vars_in_model]))
opa_census_clean <- opa_census %>%
filter(!is.na(number_of_bathrooms))
pred_log_3 <- predict(model3, newdata = opa_census_clean)
smearing_factor_3 <- mean(exp(residuals(model3)))
pred_y_corrected_3 <- exp(pred_log_3) * smearing_factor_3
rmse_bonus <- sqrt(mean((pred_y_corrected_3 - opa_census_clean$sale_price)^2, na.rm = TRUE))
rmse_bonus
rmse_norm <- rmse_bonus / mean(opa_census_clean$sale_price)
rmse_norm
model3 <- lm(log(sale_price) ~ log(total_livable_area)  +
number_of_bathrooms +
I(house_age^2) +
house_age +
log(median_income) +
ba_rate +
unemployment_rate +
sqrt(crime_count) +
log(nearest_hospital_knn3) +
interior_condition +
quality_grade_num +
fireplaces +
garage_spaces +
#I(vacancy_rate^2) +
central_air_dummy +
central_air_missing +
(interior_condition * log(median_income))+
city_dist_m+
factor(zip_code),
data = opa_census
)
summary(model3)
opa_var <- opa_var %>%
mutate(
non_market = (((.sale_price < 0.10*.market_value) | .sale_price < 2000) | (.sale_price> 10*.market_value)),
house_age = 2025 - year_built
)
opa_var <- opa_var %>%
mutate(
non_market = (((sale_price < 0.10*market_value) | sale_price < 2000) | (sale_price> 10*market_value)),
house_age = 2025 - year_built
)
opa_selected <- opa_var %>%
filter(
non_market==0
)
# load data
opa <- read_csv("opa_properties_public.csv")
# filter sales (2023 - 2024)
opa_clean <- opa %>%
mutate(sale_date = as.Date(sale_date)) %>%
filter(sale_date >= "2023-01-01" & sale_date <= "2024-12-31",
category_code == "1"
)
sum(is.na(opa_clean$central_air))
#quality_grade
#fireplaces
#garage_spaces
# Select relevant variables
opa_var <- opa_clean %>%
dplyr::select(
sale_date, sale_price, market_value, building_code_description,
total_livable_area, number_of_bedrooms, number_of_bathrooms,
number_stories, garage_spaces, central_air, quality_grade,
interior_condition, exterior_condition, year_built, off_street_open,
zip_code, geographic_ward, census_tract, zoning, owner_1,
category_code_description, shape, fireplaces
)
#filter to residential properties(SINGLE FAMILY)
opa_var <- opa_var %>%
distinct() %>%
filter(
!is.na(total_livable_area) & total_livable_area > 0,
!is.na(year_built) & year_built > 0 & year_built < 2025,
!is.na(number_of_bathrooms),
garage_spaces<30
)
#numeric quality_grade
valid_grades <- c("A+", "A", "A-",
"B+", "B", "B-",
"C+", "C", "C-",
"D+", "D", "D-",
"E+", "E", "E-")
opa_var <- opa_var %>%
filter(quality_grade %in% valid_grades) %>%
mutate(
quality_grade = factor(quality_grade, levels = valid_grades, ordered = TRUE),
quality_grade_num = rev(seq_along(valid_grades))[as.numeric(quality_grade)]
)
#central_air
opa_var <- opa_var %>%
mutate(
central_air_dummy = case_when(
central_air %in% c(1, "Y", "y") ~ 1,
central_air %in% c(0, "N", "n") ~ 0,
TRUE ~ NA_real_
),
central_air_missing = if_else(is.na(central_air), 1, 0),
central_air_dummy = if_else(is.na(central_air_dummy), 0, central_air_dummy)
)
# remove obvious errors & handle missing values, create house age
opa_var <- opa_var %>%
mutate(
non_market = (((sale_price < 0.10*market_value) | sale_price < 2000) | (sale_price> 10*market_value)),
house_age = 2025 - year_built
)
opa_selected <- opa_var %>%
filter(
non_market==0
)
#opa_selected <- opa_selected %>%
#  filter(sale_price <= quantile(sale_price, 0.99, na.rm = TRUE))
opa_non_market <- opa_var %>%
filter(non_market ==1)
opa_selected2 <- opa_var
model1 <- lm(log(sale_price) ~ total_livable_area + number_of_bedrooms +
number_of_bathrooms + house_age,
data = opa_census)
summary(model1)
# 假设已经运行了 library(tidyverse) 和 library(patchwork)
# 1. 创建因变量的对数形式 如果它还没有在 opa_census 中
opa_census_plot <- opa_census %>%
mutate(log_sale_price = log(sale_price))
# 2. 绘制第一个自变量：total_livable_area
p1 <- ggplot(opa_census_plot, aes(x = total_livable_area, y = log_sale_price)) +
geom_point(alpha = 0.5, color = "darkred") +
geom_smooth(method = "lm", color = "blue", se = FALSE) + # 添加线性趋势线
labs(title = "Log(Sale Price) vs. Livable Area",
x = "Total Livable Area", y = "Log(Sale Price)") +
theme_minimal()
# 3. 绘制第二个自变量：number_of_bedrooms
p2 <- ggplot(opa_census_plot, aes(x = number_of_bedrooms, y = log_sale_price)) +
geom_point(alpha = 0.5, color = "darkred") +
geom_smooth(method = "lm", color = "blue", se = FALSE) +
labs(title = "Log(Sale Price) vs. Bedrooms",
x = "Number of Bedrooms", y = "") + # 避免重复 Y 轴标签
theme_minimal()
# 4. 绘制第三个自变量：number_of_bathrooms
p3 <- ggplot(opa_census_plot, aes(x = number_of_bathrooms, y = log_sale_price)) +
geom_point(alpha = 0.5, color = "darkred") +
geom_smooth(method = "lm", color = "blue", se = FALSE) +
labs(title = "Log(Sale Price) vs. Bathrooms",
x = "Number of Bathrooms", y = "Log(Sale Price)") +
theme_minimal()
# 5. 绘制第四个自变量：house_age
p4 <- ggplot(opa_census_plot, aes(x = house_age, y = log_sale_price)) +
geom_point(alpha = 0.5, color = "darkred") +
geom_smooth(method = "lm", color = "blue", se = FALSE) +
labs(title = "Log(Sale Price) vs. House Age",
x = "House Age (2025 - Year Built)", y = "") + # 避免重复 Y 轴标签
theme_minimal()
# 6. 使用 patchwork 组合并显示图表
(p1 | p2) / (p3 | p4)
model1.1 <- lm(log(sale_price) ~ log(total_livable_area) + number_of_bedrooms +
number_of_bathrooms + house_age,
data = opa_census)
summary(model1.1)
opa_census_plot <- opa_census %>%
mutate(log_sale_price = log(sale_price))
# 2. 绘制第一个自变量：total_livable_area
p1 <- ggplot(opa_census_plot, aes(x = log(total_livable_area), y = log_sale_price)) +
geom_point(alpha = 0.5, color = "darkred") +
geom_smooth(method = "lm", color = "blue", se = FALSE) + # 添加线性趋势线
labs(title = "Log(Sale Price) vs. Log(Livable Area)",
x = "Total Livable Area", y = "Log(Sale Price)") +
theme_minimal()
# 3. 绘制第二个自变量：number_of_bedrooms
p2 <- ggplot(opa_census_plot, aes(x = number_of_bedrooms, y = log_sale_price)) +
geom_point(alpha = 0.5, color = "darkred") +
geom_smooth(method = "lm", color = "blue", se = FALSE) +
labs(title = "Log(Sale Price) vs. Bedrooms",
x = "Number of Bedrooms", y = "") + # 避免重复 Y 轴标签
theme_minimal()
# 4. 绘制第三个自变量：number_of_bathrooms
p3 <- ggplot(opa_census_plot, aes(x = number_of_bathrooms, y = log_sale_price)) +
geom_point(alpha = 0.5, color = "darkred") +
geom_smooth(method = "lm", color = "blue", se = FALSE) +
labs(title = "Log(Sale Price) vs. Bathrooms",
x = "Number of Bathrooms", y = "Log(Sale Price)") +
theme_minimal()
# 5. 绘制第四个自变量：house_age
p4 <- ggplot(opa_census_plot, aes(x = (house_age), y = log_sale_price)) +
geom_point(alpha = 0.5, color = "darkred") +
geom_smooth(method = "lm", color = "blue", se = FALSE) +
labs(title = "Log(Sale Price) vs. House Age",
x = "House Age (2025 - Year Built)", y = "") + # 避免重复 Y 轴标签
theme_minimal()
p5 <- ggplot(opa_census_plot, aes(x = log(median_income), y = log_sale_price)) +
geom_point(alpha = 0.5, color = "darkred") +
geom_smooth(method = "lm", color = "blue", se = FALSE) +
labs(title = "Log(Sale Price) vs. median_income",
x = "House Age (2025 - Year Built)", y = "") + # 避免重复 Y 轴标签unemployment_rate
theme_minimal()
p6 <- ggplot(opa_census_plot, aes(x = unemployment_rate, y = log_sale_price)) +
geom_point(alpha = 0.5, color = "darkred") +
geom_smooth(method = "lm", color = "blue", se = FALSE) +
labs(title = "Log(Sale Price) vs. unemployment_rate",
x = "House Age (2025 - Year Built)", y = "") + # 避免重复 Y 轴标签unemployment_rate
theme_minimal()
p7 <- ggplot(opa_census_plot, aes(x = ba_rate, y = log_sale_price)) +
geom_point(alpha = 0.5, color = "darkred") +
geom_smooth(method = "lm", color = "blue", se = FALSE) +
labs(title = "Log(Sale Price) vs. ba_rate",
x = "House Age (2025 - Year Built)", y = "") + # 避免重复 Y 轴标签unemployment_rate
theme_minimal()
p7
# 6. 使用 patchwork 组合并显示图表
(p1 | p2 | p3) / (p4 | p5 | p6)
model2 <- lm(log(sale_price) ~ log(total_livable_area) + number_of_bedrooms +
number_of_bathrooms + house_age +
median_income + ba_rate + (unemployment_rate),
data = opa_census)
summary(model2)
model3 <- lm(log(sale_price) ~ log(total_livable_area)  +
number_of_bathrooms +
I(house_age^2) +
house_age +
log(median_income) +
ba_rate +
unemployment_rate +
sqrt(crime_count) +
log(nearest_hospital_knn3) +
interior_condition +
quality_grade_num +
fireplaces +
garage_spaces +
#I(vacancy_rate^2) +
central_air_dummy +
central_air_missing +
(interior_condition * log(median_income))+
city_dist_m+
factor(zip_code),
data = opa_census
)
summary(model3)
opa_census_clean <- opa_census
pred_log_3 <- predict(model3, newdata = opa_census_clean)
smearing_factor_3 <- mean(exp(residuals(model3)))
pred_y_corrected_3 <- exp(pred_log_3) * smearing_factor_3
rmse_bonus <- sqrt(mean((pred_y_corrected_3 - opa_census_clean$sale_price)^2, na.rm = TRUE))
rmse_bonus
rmse_norm <- rmse_bonus / mean(opa_census_clean$sale_price)
rmse_norm
library(tidyverse)
library(sf)
library(tidycensus)
library(tigris)
options(tigris_use_cache = TRUE, tigris_class = "sf")
library(MASS)
library(dplyr)
library(scales)
library(ggplot2)
library(caret)
model_market <- lm(sale_price ~ market_value, data = opa_var)
opa_var$residual <- resid(model_market)
sd_resid <- sd(opa_var$residual, na.rm = TRUE)
opa_bonus <- opa_var %>%
mutate(high_deviation = residual > 3 * sd_resid)  # 超过3倍标准差的高价点
opa_bonus %>%
summarise(
n_total = n(),
n_high_dev = sum(high_deviation, na.rm = TRUE),
share_high_dev = mean(high_deviation, na.rm = TRUE)
)
opa_mdata <- opa_bonus %>%
filter(
non_market == 0,
high_deviation == 0
)
model_log <- lm(log(sale_price) ~ log(market_value), data = opa_mdata)
summary(model_log)
# Step 1: 预测 log(sale_price)
pred_log1 <- predict(model_log, newdata = opa_non_market)
# Step 2: smearing 校正（从你前面的逻辑延续）
smearing_factor1 <- mean(exp(residuals(model_log)))
# Step 3: 反变换为实际房价
opa_non_market$sale_price_predicted <- exp(pred_log1) * smearing_factor1
rmse_value <- sqrt(mean((opa_non_market$sale_price_predicted - opa_non_market$market_value)^2, na.rm = TRUE))
rmse_value
# Transform to sf object
opa_sf2 <- st_as_sf(opa_non_market, wkt = "shape", crs = 2272) %>%
st_transform(4326)
opa_census_bonus <- st_join(opa_sf2, philly_census, join = st_within) %>%
filter(!is.na(median_income))
Transit <- read_csv("C:/Users/12345/Documents/GitHub/PPA_midterm/Transit.csv")
transit_sf <- st_as_sf(Transit, coords = c("Lon", "Lat"), crs = 4326) %>%
st_transform(st_crs(opa_census_bonus))
radius <- 400
opa_census_bonus$transit_count <- lengths(st_is_within_distance(opa_census_bonus, transit_sf, dist = radius))
read_csv("C:/Users/12345/Documents/GitHub/PPA_midterm/Transit.csv", show_col_types = FALSE)
# Load crime data and create buffer-based feature
crime <- read_csv("C:/Users/12345/Documents/GitHub/PPA_midterm/crime_sel.csv") %>%
filter(!is.na(lat) & !is.na(lng))
crime_sf <- st_as_sf(crime, coords = c("lng", "lat"), crs = 4326) %>%
st_transform(st_crs(opa_census_bonus))
radius_cri <- 250
opa_census_bonus$crime_count <- lengths(st_is_within_distance(opa_census_bonus, crime_sf, dist = radius_cri))
read_csv("C:/Users/12345/Documents/GitHub/PPA_midterm/crime_sel.csv", show_col_types = FALSE)
poi_sf <- st_read("data/gis_osm_pois_a_free_1.shp", quiet = TRUE) %>%
st_transform(st_crs(opa_census))
radius_poi <- 400
opa_census_bonus$poi_count <- lengths(
st_is_within_distance(opa_census_bonus, poi_sf, dist = radius_poi)
)
library(sf)
library(nngeo)
opa_census_centroid <- st_centroid(opa_census_bonus)
nearest_hospital_index <- st_nn(
opa_census_centroid,
hospital_sf,
k = 3,
returnDist = TRUE
)
opa_census_bonus$nearest_hospital_knn3 <- sapply(nearest_hospital_index$dist, mean)
opa_census_bonus$nearest_hospital_m <- sapply(nearest_hospital_index$dist, min)
ccd_boundary <- st_read("CCD_BOUNDARY.geojson", quiet = TRUE) %>%
st_transform(st_crs(opa_census))
ccd_center <- st_centroid(ccd_boundary)
opa_census_bonus$city_dist_m <- st_distance(
opa_census_bonus,
ccd_center,
by_element = FALSE
)
opa_census_bonus$city_dist_m <- as.numeric(opa_census_bonus$city_dist_m)
opa_census_2 <- opa_census %>%
mutate(sale_price_predicted= sale_price)
opa_census_all <- bind_rows(opa_census_2, opa_census_bonus)
opa_census_all <- opa_census_all %>%
mutate(weight_mix = ifelse(non_market == 1, 0.2, 0.8))
model_bonus3 <- lm(log(sale_price_predicted) ~ log(total_livable_area)  +
number_of_bathrooms +
I(house_age^2) +
house_age +
log(median_income) +
ba_rate +
unemployment_rate +
sqrt(crime_count) +
log(nearest_hospital_knn3) +
interior_condition +
quality_grade_num +
fireplaces +
garage_spaces +
#I(vacancy_rate^2) +
central_air_dummy +
central_air_missing +
(interior_condition * log(median_income))+
city_dist_m+
factor(zip_code),
data = opa_census_all
)
summary(model_bonus3)
colSums(is.na(opa_census_all))
opa_census_2_clean <- opa_census_2
pred_log_bonus <- predict(model_bonus3, newdata = opa_census_2_clean)
smearing_factor_bonus <- mean(exp(residuals(model_bonus3)))
pred_y_corrected_bonus <- exp(pred_log_bonus) * smearing_factor_bonus
rmse_bonus <- sqrt(mean((pred_y_corrected_bonus - opa_census_2_clean$sale_price_predicted)^2, na.rm = TRUE))
rmse_bonus
rmse_norm <- rmse_bonus / mean(opa_census_2_clean$sale_price_predicted)
rmse_norm
options(scipen = 999)
plot(opa_census_2_clean$sale_price_predicted, pred_y_corrected_bonus,
xlab = "Actual Price", ylab = "Predicted Price",
main = "Predicted vs Actual Sale Price",
pch = 19, col = rgb(0.2,0.4,0.6,0.4))
abline(0,1,col="red",lwd=2)
opa_census_all_clean <- opa_census_all %>%
filter(!is.na(number_of_bathrooms))
pred_log_bonus2 <- predict(model_bonus3, newdata = opa_census_all_clean)
smearing_factor_bonus <- mean(exp(residuals(model_bonus3)))
pred_y_corrected_bonus <- exp(pred_log_bonus2) * smearing_factor_bonus
rmse_bonus <- sqrt(mean((pred_y_corrected_bonus - opa_census_all_clean$sale_price_predicted)^2, na.rm = TRUE))
rmse_bonus
rmse_norm <- rmse_bonus / mean(opa_census_all_clean$sale_price_predicted)
rmse_norm
options(scipen = 999)
plot(opa_census_all_clean$sale_price_predicted, pred_y_corrected_bonus,
xlab = "Actual Price", ylab = "Predicted Price",
main = "Predicted vs Actual Sale Price",
pch = 19, col = rgb(0.2,0.4,0.6,0.4))
abline(0,1,col="red",lwd=2)
names(opa_census_all)
vars_in_model <- c("total_livable_area", "number_of_bathrooms", "house_age",
"median_income", "ba_rate", "crime_count",
"transit_count", "nearest_hospital_m", "geographic_ward.y")
# 检查这些变量的缺失情况
colSums(is.na(opa_census_all_clean[, vars_in_model]))
opa_census_all_clean <- opa_census_all %>%
filter(!is.na(number_of_bathrooms))
pred_log_bonus2 <- predict(model_bonus3, newdata = opa_census_all_clean)
smearing_factor_bonus <- mean(exp(residuals(model_bonus3)))
pred_y_corrected_bonus <- exp(pred_log_bonus2) * smearing_factor_bonus
rmse_bonus <- sqrt(mean((pred_y_corrected_bonus - opa_census_all_clean$sale_price_predicted)^2, na.rm = TRUE))
rmse_bonus
rmse_norm <- rmse_bonus / mean(opa_census_all_clean$sale_price_predicted)
rmse_norm
options(scipen = 999)
plot(opa_census_all_clean$sale_price_predicted, pred_y_corrected_bonus,
xlab = "Actual Price", ylab = "Predicted Price",
main = "Predicted vs Actual Sale Price",
pch = 19, col = rgb(0.2,0.4,0.6,0.4))
abline(0,1,col="red",lwd=2)
opa_census_all <- opa_census_all %>%
mutate(weight_mix = ifelse(non_market == 1, 0.2, 1))
model_bonus3 <- lm(log(sale_price_predicted) ~ log(total_livable_area)  +
number_of_bathrooms +
I(house_age^2) +
house_age +
log(median_income) +
ba_rate +
unemployment_rate +
sqrt(crime_count) +
log(nearest_hospital_knn3) +
interior_condition +
quality_grade_num +
fireplaces +
garage_spaces +
#I(vacancy_rate^2) +
central_air_dummy +
central_air_missing +
(interior_condition * log(median_income))+
city_dist_m+
factor(zip_code),
data = opa_census_all
)
summary(model_bonus3)
opa_census_2_clean <- opa_census_2
pred_log_bonus <- predict(model_bonus3, newdata = opa_census_2_clean)
smearing_factor_bonus <- mean(exp(residuals(model_bonus3)))
pred_y_corrected_bonus <- exp(pred_log_bonus) * smearing_factor_bonus
rmse_bonus <- sqrt(mean((pred_y_corrected_bonus - opa_census_2_clean$sale_price_predicted)^2, na.rm = TRUE))
rmse_bonus
rmse_norm <- rmse_bonus / mean(opa_census_2_clean$sale_price_predicted)
rmse_norm
options(scipen = 999)
plot(opa_census_2_clean$sale_price_predicted, pred_y_corrected_bonus,
xlab = "Actual Price", ylab = "Predicted Price",
main = "Predicted vs Actual Sale Price",
pch = 19, col = rgb(0.2,0.4,0.6,0.4))
abline(0,1,col="red",lwd=2)
mean(opa_census_all$non_market == 1, na.rm = TRUE)
mean(opa_census_all$non_market == 1, na.rm = TRUE)
opa_census_all <- opa_census_all %>%
mutate(weight_mix = ifelse(non_market == 1, 0.25, 0.75))
model_bonus3 <- lm(log(sale_price_predicted) ~ log(total_livable_area)  +
number_of_bathrooms +
I(house_age^2) +
house_age +
log(median_income) +
ba_rate +
unemployment_rate +
sqrt(crime_count) +
log(nearest_hospital_knn3) +
interior_condition +
quality_grade_num +
fireplaces +
garage_spaces +
#I(vacancy_rate^2) +
central_air_dummy +
central_air_missing +
(interior_condition * log(median_income))+
city_dist_m+
factor(zip_code),
data = opa_census_all
)
summary(model_bonus3)
colSums(is.na(opa_census_all))
opa_census_2_clean <- opa_census_2
pred_log_bonus <- predict(model_bonus3, newdata = opa_census_2_clean)
smearing_factor_bonus <- mean(exp(residuals(model_bonus3)))
pred_y_corrected_bonus <- exp(pred_log_bonus) * smearing_factor_bonus
rmse_bonus <- sqrt(mean((pred_y_corrected_bonus - opa_census_2_clean$sale_price_predicted)^2, na.rm = TRUE))
rmse_bonus
rmse_norm <- rmse_bonus / mean(opa_census_2_clean$sale_price_predicted)
rmse_norm
options(scipen = 999)
plot(opa_census_2_clean$sale_price_predicted, pred_y_corrected_bonus,
xlab = "Actual Price", ylab = "Predicted Price",
main = "Predicted vs Actual Sale Price",
pch = 19, col = rgb(0.2,0.4,0.6,0.4))
abline(0,1,col="red",lwd=2)
