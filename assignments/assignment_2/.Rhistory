geom_sf(data = hospitals_4326, shape = 21, fill = "white", color = "black",
size = 1.1, alpha = 0.8, inherit.aes = FALSE) +
scale_fill_viridis_c(
option = "cividis",
na.value = "grey90",
name = "Underserved share\n(of vulnerable tracts)",
labels = label_percent(accuracy = 1)
) +
labs(
title    = "Healthcare Access Challenges in Pennsylvania",
subtitle = "Counties filled by % of vulnerable tracts > 15 miles from a hospital",
caption  = "Sources: ACS 5-year (2022), lecture hospital dataset. Distances computed in EPSG:5070; map shown in WGS84."
) +
theme_void() +
theme(
legend.position = "right",
plot.title      = element_text(face = "bold"),
plot.caption    = element_text(hjust = 0)
)
# Create detailed tract-level map
## 1)Ensure "underserved" exists; keep only vulnerable tracts and make a status label
vuln_dist_4326 <- vulnerable_tracts_dist_5070 %>%
mutate(underserved = if (!"underserved" %in% names(.)) dist_to_hospital_mi > 15 else underserved) %>%
st_transform(crs_display) %>%
mutate(
status = ifelse(underserved, "Underserved vulnerable", "Other vulnerable")
)
## 2)Map
tracts_4326 <- sf::st_transform(census_tracts, 4326)
ggplot() +
# county boundaries (context; subtle)
geom_sf(data = pa_counties_4326, fill = NA, color = "grey40", linewidth = 0.3) +
# tracts
geom_sf(data = tracts_4326, fill = NA, color = "grey80", linewidth = 0.05) +
# vulnerable tracts
geom_sf(data = subset(vuln_dist_4326, status == "Other vulnerable"),
aes(fill = status), color = "black", linewidth = 0.15, alpha = 0.9) +
# underserved vulnerable tracts
geom_sf(data = subset(vuln_dist_4326, status == "Underserved vulnerable"),
aes(fill = status), color = "black", linewidth = 0.15, alpha = 0.9) +
# hospitals (points)
geom_sf(
data = hospitals_4326,
aes(shape = "Hospitals"),
fill = "white", color = "black",
size = 1.2, alpha = 0.9,
inherit.aes = FALSE,
show.legend = "point"
) +
# fills for tracts
scale_fill_manual(
name = NULL,
values = c("Other vulnerable" = "#9ecae1", "Underserved vulnerable" = "#08519c")
) +
# shape for hospitals + legend tweaks
scale_shape_manual(name = NULL, values = c("Hospitals" = 21)) +
guides(
fill  = guide_legend(order = 1, override.aes = list(shape = NA)),
shape = guide_legend(order = 2, override.aes = list(fill = "white", color = "black", size = 2))
) +
labs(
title    = "Underserved Vulnerable Census Tracts in Pennsylvania",
subtitle = "Underserved = vulnerable tracts (>15 miles to nearest hospital); counties and tract grids shown for context",
caption  = "Sources: ACS 5-year (2022); hospital dataset. Distances: EPSG:5070; map: WGS84."
) +
theme_void() +
theme(legend.position = "right", plot.title = element_text(face = "bold"))
# Create distribution visualization
## A small helper used in captions
median_dist <- median(vulnerable_tracts_dist_5070$dist_to_hospital_mi, na.rm = TRUE)
## 1) People-weighted histogram of distances (highlighting the 15-mile threshold)
vulnerable_tracts_dist_5070 |>
mutate(beyond15 = factor(dist_to_hospital_mi > 15,
levels = c(FALSE, TRUE),
labels = c("≤ 15 miles", "> 15 miles"))) |>
ggplot(aes(x = dist_to_hospital_mi, weight = total_pop, fill = beyond15)) +
geom_histogram(binwidth = 1, boundary = 0, color = "white") +
scale_fill_manual(values = c("≤ 15 miles" = "#9ecae1", "> 15 miles" = "#08519c"),
name = NULL) +
scale_y_continuous(labels = comma) +
labs(
title = "How far are vulnerable residents from hospitals?",
x = "Distance to nearest hospital (miles)",
y = "Residents (people)"
) +
theme_minimal(base_size = 12) +
theme(legend.position = "right")
# 2) Scatter: Distance vs. tract population (vulnerable tracts)
ggplot(vulnerable_tracts_dist_5070,
aes(x = dist_to_hospital_mi, y = total_pop, color = underserved)) +
geom_point(alpha = 0.7) +
scale_y_continuous(labels = comma, trans = "log10") +
scale_color_manual(values = c(`FALSE` = "#9ecae1", `TRUE` = "#08519c"),
name = "Underserved\n(>15 mi)") +
labs(
title = "Distance vs. population size across vulnerable tracts",
x = "Distance to nearest hospital (miles)",
y = "Tract population (people)"
) +
theme_minimal(base_size = 12) +
theme(legend.position = "right")
# Load your additional dataset
## 1) Philly tracts
phl_tracts <- tracts(state = "PA", county = "Philadelphia", cb = TRUE, year = 2022)
phl_boundary <- counties(state = "PA", cb = TRUE, year = 2022) %>%
filter(NAME == "Philadelphia")
## 2)Reach children data
phl_children <- get_acs(
geography = "tract",
variables = c(child_pop = "B09001_001"),
state = "PA",
county = "Philadelphia",
year = 2022,
output = "wide"
)
tracts_with_children <- phl_tracts %>%
left_join(phl_children, by = "GEOID")
## 3)Reach POI
### recreation center raw data(philly)
PPR_Program_sites <- st_read("https://opendata.arcgis.com/api/v3/datasets/9eb26a787a6e448ba426eea7f9f0d93a_0/downloads/data?format=geojson&spatialRefId=4326")
### schools raw data(philly)
schools <- st_read("https://hub.arcgis.com/api/v3/datasets/d46a7e59e2c246c891fbee778759717e_0/downloads/data?format=geojson&spatialRefId=4326&where=1%3D1")
### libraries raw data(global)
libraries <- st_read( "D:/PersonalFiles/MUSA/PPA/portfolio/portfolio-setup-demiyang12/assignments/assignment_2/data/Libraries/Libraries.gpkg",layer = "parsed")
## 4) Check the data
list(
phl_tracts_rows = nrow(phl_tracts),
phl_children_rows = nrow(phl_children),
schools_rows = nrow(schools),
libraries_rows = nrow(libraries)
)
head(phl_tracts)
head(phl_children)
# Data cleaning
## 1)Recreation center
names(PPR_Program_sites)
### Check the unique values containing "Recreation" in the field and see how they are written
unique(unlist(PPR_Program_sites))
unique(PPR_Program_sites$FACILITY_TYPE)
### Filter"Recreation Centers"
recreation_centers <- PPR_Program_sites %>%
filter(
grepl("recreation", PARK_NAME, ignore.case = TRUE)
)
### See results
nrow(recreation_centers)
head(recreation_centers)
## 2)Libraries
### reproject CRS of libraries to boundary's
st_crs(libraries)
st_crs(phl_boundary)
libraries <- st_transform(libraries, st_crs(phl_boundary))
### Cut out the libraries within the Philly area
libraries_phl <- st_intersection(libraries, phl_boundary)
### See results
nrow(libraries_phl)
head(libraries_phl)
## 3)Summary table
summary_table <- tibble(
Dataset = c("Libraries",
"Schools",
"Recreation Centers"),
Features = c(nrow(libraries_phl),
nrow(schools),
nrow(recreation_centers)),
CRS = c(st_crs(libraries)$input,
st_crs(schools)$input,
st_crs(PPR_Program_sites)$input)
)
kable(summary_table, caption = "Summary of Datasets Used")
# Unify the coordinates and prepare the buffer
## 1) Reproject all layers to 5070
crs_analysis <- 5070
crs_map      <- 4326
half_mile_m  <- set_units(0.3, "mile") %>% set_units("m") %>% drop_units()
phl_tracts_5070        <- st_transform(phl_tracts, crs_analysis)
phl_boundary_5070      <- st_transform(phl_boundary, crs_analysis)
schools_5070           <- st_transform(schools, crs_analysis)
recreation_centers_5070<- st_transform(recreation_centers, crs_analysis)
libraries_phl_5070     <- st_transform(libraries_phl, crs_analysis)
## 2) Create buffer(schools & libraries, recreation centers do sensitivity)
buf_schools   <- st_buffer(schools_5070,  dist = half_mile_m)
buf_libraries <- st_buffer(libraries_phl_5070, dist = half_mile_m)
## 3) Accessible region
access_union_core <- st_union(st_union(buf_schools), st_union(buf_libraries))
## 4) Use recreation center to sensitivity comparison
buf_recreation <- st_buffer(recreation_centers_5070, dist = half_mile_m)
access_union_all <- st_union(access_union_core, st_union(buf_recreation))
## 5)Check the result
st_crs(schools_5070)
st_crs(libraries_phl_5070)
st_crs(phl_tracts_5070)
ggplot() +
geom_sf(data = phl_boundary_5070, fill = NA, color = "black") +
geom_sf(data = buf_schools, fill = "darkslateblue", alpha = 0.3) +
geom_sf(data = buf_libraries, fill = "steelblue", alpha = 0.3) +
labs(title = "0.5-mile Buffers Around Schools and Libraries")
# Calculate the "education coverage rate" and "child density" of each census tracts
## 1) Area (m²) and child density (per square kilometer)
tracts_metrics <- phl_tracts_5070 %>%
mutate(tract_area_m2 = as.numeric(st_area(geometry)),
tract_area_km2 = tract_area_m2 / 1e6) %>%
left_join(tracts_with_children %>% st_drop_geometry() %>%
select(GEOID, child_pop = child_popE), by = "GEOID") %>%
mutate(child_density = ifelse(tract_area_km2 > 0, child_pop / tract_area_km2, NA_real_))
## 2) Coverage rate = Intersection area between the reachable zone and the census zone (m²)
intersect_access <- st_intersection(
tracts_metrics %>% select(GEOID),
st_make_valid(access_union_core)
) %>%
mutate(access_area_m2 = as.numeric(st_area(geometry))) %>%
st_drop_geometry() %>%
group_by(GEOID) %>%
summarize(access_area_m2 = sum(access_area_m2, na.rm = TRUE), .groups = "drop")
tracts_metrics <- tracts_metrics %>%
left_join(intersect_access, by = "GEOID") %>%
mutate(access_area_m2 = coalesce(access_area_m2, 0),
access_ratio   = pmin(access_area_m2 / tract_area_m2, 1))
## 3)Check the statistical distribution of child_density and access_ratio
summary(tracts_metrics[, c("child_density", "access_ratio")])
ggplot(tracts_metrics) +
geom_histogram(aes(x = child_density), bins = 30, fill = "lightblue", color = "white") +
labs(title = "Distribution of Child Density (children/km²)")
ggplot(tracts_metrics) +
geom_histogram(aes(x = access_ratio), bins = 30, fill = "darkseagreen3", color = "white") +
labs(title = "Distribution of Access Ratio (coverage rate)")
ggplot() +
geom_sf(data = tracts_metrics, aes(fill = child_density), color = NA) +
scale_fill_viridis_c(option="mako", direction=-1) +
labs(title = "Child Density by Census Tract")
ggplot() +
geom_sf(data = tracts_metrics, aes(fill = access_ratio), color = NA) +
scale_fill_viridis_c(option="mako", direction=-1) +
labs(title = "Education Access Ratio by Census Tract")
# Define education desert
p_target <- 0.25
tracts_metrics <- tracts_metrics %>%
mutate(
z_child   = as.numeric(scale(child_density)),
z_access  = as.numeric(scale(-access_ratio)),
score     = 0.5 * z_child + 0.5 * z_access
) %>%
mutate(
cutoff = quantile(score, 1 - p_target, na.rm = TRUE),
vulnerable_local = score >= cutoff
)
cutoff_value <- unique(tracts_metrics$cutoff)
count_table  <- table(tracts_metrics$vulnerable_local)
percent_vuln <- mean(tracts_metrics$vulnerable_local, na.rm = TRUE)
summary_vulnerable <- tibble(
Metric = c("Cutoff Score",
"Tracts classified as TRUE (Educational Desert)",
"Tracts classified as FALSE",
"Share of Desert Tracts"),
Value = c(
round(cutoff_value, 3),
as.integer(count_table["TRUE"]),
as.integer(count_table["FALSE"]),
paste0(round(percent_vuln * 100, 1), "%")
)
)
kable(summary_vulnerable, caption = "Summary of Educational Desert Classification")
# Draw the map
## 1) Back to WGS84
tracts_map           <- st_transform(tracts_metrics, crs_map)
phl_boundary_plot    <- st_transform(phl_boundary_5070, crs_map)
schools_plot         <- st_transform(schools, crs_map) %>% mutate(Type = "Schools")
libraries_plot       <- st_transform(libraries_phl, crs_map) %>% mutate(Type = "Libraries")
facilities <- dplyr::bind_rows(
dplyr::select(schools_plot,  Type),
dplyr::select(libraries_plot, Type)
)
## 2) map
ggplot() +
geom_sf(
data = tracts_map,
aes(fill = vulnerable_local),
color = "grey20", size = 0.15
) +
geom_sf(
data = phl_boundary_plot,
fill = NA, color = "black", linewidth = 0.4
) +
geom_sf(
data = facilities,
aes(color = Type),
shape = 16,
size = 1,
alpha = 0.3,
show.legend = TRUE
) +
scale_fill_manual(
values = c("FALSE" = "whitesmoke", "TRUE" = "wheat"),
name = "Educational desert",
labels = c("False", "True")
) +
scale_color_manual(
name = "Facilities",
values = c("Schools" = "sienna", "Libraries" = "cornsilk4", alpha = 0.3)
) +
guides(
color = guide_legend(override.aes = list(shape = 16, size = 3, alpha = 1))
) +
labs(
title = "Educational Desert in Philadelphia",
subtitle = "Areas with high child density and low coverage of schools & libraries",
caption = "CRS for map = WGS84"
) +
theme_minimal() +
theme(
legend.position = "right",
axis.text = element_blank(),
axis.ticks = element_blank(),
panel.grid = element_blank()
)
legend_table <- tibble(
Category = c("Educational Desert", "Schools", "Libraries"),
Meaning = c("High child density, low access",
"Education facilities",
"Public libraries providing learning access")
)
kable(legend_table, caption = "Legend Explanation")
# Sensitivity test (add Recreation Centers)
## 1) Calculate the coverage rate after adding recreation centers"
intersect_access_all <- st_intersection(
tracts_metrics %>% select(GEOID),
st_make_valid(access_union_all)
) %>%
mutate(access_area_m2_all = as.numeric(st_area(geometry))) %>%
st_drop_geometry() %>%
group_by(GEOID) %>%
summarize(access_area_m2_all = sum(access_area_m2_all, na.rm = TRUE), .groups = "drop")
tracts_metrics_all <- tracts_metrics %>%
left_join(intersect_access_all, by = "GEOID") %>%
mutate(
access_area_m2_all = coalesce(access_area_m2_all, 0),
access_ratio_all   = pmin(access_area_m2_all / tract_area_m2, 1),
z_access_all       = as.numeric(scale(-access_ratio_all)),
score_all          = 0.5 * z_child + 0.5 * z_access_all
) %>%
mutate(
cutoff_all = quantile(score_all, 1 - p_target, na.rm = TRUE),
vulnerable_all = score_all >= cutoff_all
)
## 2) Compare with the previous results
sens_compare <- tracts_metrics_all %>%
st_drop_geometry() %>%
select(GEOID, vulnerable_core = vulnerable_local, vulnerable_all)
sens_compare <- sens_compare %>%
mutate(
status = dplyr::case_when(
vulnerable_core &  vulnerable_all  ~ "Stable: Desert",
!vulnerable_core & !vulnerable_all ~ "Stable: Not Desert",
vulnerable_core & !vulnerable_all  ~ "Flipped: Rescued by Rec",
!vulnerable_core &  vulnerable_all ~ "Flipped: Newly Desert",
TRUE ~ "Other"
)
)
## 3) Summary table for sensitivity
total_tracts <- nrow(sens_compare)
sens_table <- sens_compare %>%
count(status, name = "Count") %>%
mutate(Share = paste0(round(100 * Count / total_tracts, 1), "%")) %>%
arrange(desc(Count))
## 4) The degree of overlap between two sets of "deserts"
jaccard <- with(sens_compare, sum(vulnerable_core & vulnerable_all, na.rm = TRUE) /
sum(vulnerable_core | vulnerable_all, na.rm = TRUE))
kable(
bind_rows(
sens_table,
tibble(
status = "Jaccard (core vs all)",
Count  = NA_integer_,
Share  = paste0(round(jaccard * 100, 1), "%")
)
),
caption = "Sensitivity: Effect of Adding Recreation Centers on 'Educational Desert' Classification"
)
# Map the "flipped" tracts
## 1) reproject CRS to WGS 84
tracts_status_map <- tracts_metrics %>%
select(GEOID, geometry) %>%
left_join(sens_compare %>% select(GEOID, status), by = "GEOID") %>%
st_transform(crs_map)
ggplot() +
geom_sf(data = tracts_status_map, aes(fill = status), color = "grey30") +
geom_sf(data = phl_boundary_plot, fill = NA, color = "black", linewidth = 0.4) +
scale_fill_manual(
name = "Classification change",
values = c(
"Stable: Desert"        = "wheat",
"Stable: Not Desert"    = "#f7f7f7",
"Flipped: Rescued by Rec" = "olivedrab",
"Flipped: Newly Desert" = "#377eb8"
)
) +
scale_color_manual(
name = "Facilities",
values = c("Schools" = "mistyrose3", "Libraries" = "cornsilk4")
) +
guides(
color = guide_legend(override.aes = list(shape = 16, size = 3, alpha = 1))
) +
labs(
title = "Sensitivity Map: Tracts That Flip When Adding Recreation Centers",
subtitle = "‘Rescued by Rec’ = Desert under core (schools+libraries) but NOT under all (including recreation)",
caption = "CRS = WGS84"
) +
theme_minimal() +
theme(
legend.position = "right",
axis.text = element_blank(),
axis.ticks = element_blank(),
panel.grid = element_blank()
)
# Load required packages
library(sf)
library(tidyverse)
library(tigris)
library(tidycensus)
library(scales)
library(patchwork)
library(here)
library(units)
library(kableExtra)
census_api_key("42bf8a20a3df1def380f330cf7edad0dd5842ce6")
# Load spatial data
pa_counties <- st_read(here("assignments/assignment_2/data/Pennsylvania_County_Boundaries.shp"),quiet = TRUE)
hospitals <- st_read(here("assignments/assignment_2/data/hospitals.geojson"),quiet = TRUE)
census_tracts <- tracts(state = "PA", cb = TRUE)
# Check that all data loaded correctly
## 1)Make a table for checking
layers <- list(
pa_counties   = pa_counties,
hospitals     = hospitals,
census_tracts = census_tracts
)
qc <- function(x) {
data.frame(
is_sf    = inherits(x, "sf"),
n        = nrow(x),
geom     = paste(unique(as.character(st_geometry_type(x))), collapse = ", "),
crs_epsg = st_crs(x)$epsg,
crs_txt  = st_crs(x)$input,
invalid  = sum(!st_is_valid(x)),
empty    = sum(st_is_empty(x)),
bbox     = paste(round(st_bbox(x), 3), collapse = ", ")
)
}
qc_table <- do.call(rbind, lapply(layers, qc)) %>%
tibble::rownames_to_column("Layer")
kable(
qc_table,
caption = "Summary of Spatial Layers and Geometry Quality Checks",
align = "c"
) %>%
kable_styling(
full_width = FALSE,
bootstrap_options = c("striped", "hover", "condensed")
)
# Get demographic data from ACS
## 1)Reach the data
core_vars <- c(
total_pop     = "B01003_001",
median_income = "B19013_001"
)
acs_core <- get_acs(
geography = "tract",
state     = "PA",
variables = core_vars,
year      = 2022,
survey    = "acs5",
output    = "wide",
geometry  = FALSE
) %>%
transmute(
GEOID,
total_pop     = total_popE,
median_income = median_incomeE
)
## 2) Calculate the population 65 years and over
age65_vars <- c(sprintf("B01001_%03d", 20:25), sprintf("B01001_%03d", 44:49))
acs_65_wide <- get_acs(
geography = "tract", state = "PA", variables = age65_vars,
year = 2022, survey = "acs5"
) %>%
select(GEOID, variable, estimate) %>%
pivot_wider(names_from = variable, values_from = estimate)
acs_65plus <- acs_65_wide %>%
mutate(
non_na_bins = rowSums(!is.na(across(all_of(age65_vars)))),
over65 = if_else(
non_na_bins == 0, NA_real_,
rowSums(across(all_of(age65_vars)), na.rm = TRUE)
)
) %>%
select(GEOID, over65)
# Join to tract boundaries
options(tigris_progress = FALSE, tigris_use_cache = TRUE)
pa_tracts <- tracts(state = "PA", year = 2022, cb = TRUE, class = "sf")
pa_tracts_joined <- pa_tracts %>%
left_join(acs_core,   by = "GEOID") %>%
left_join(acs_65plus, by = "GEOID") %>%
mutate(
over65_share = if_else(!is.na(total_pop) & total_pop > 0, over65 / total_pop, NA_real_)
)
## 2) Count the missing data and medium data of income
income_na_n   <- sum(is.na(pa_tracts_joined$median_income))
income_median_overall <- median(pa_tracts_joined$median_income, na.rm = TRUE)
## 3) Remove missing values
pa_tracts_demo <- pa_tracts_joined %>%
filter(!is.na(median_income), !is.na(over65_share))
